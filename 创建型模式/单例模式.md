# 单例模式
- 这种模式设计到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这种类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该对象
- 使用这种模式的意图是保证一个类只有一个实例，并提供一个访问它的全局访问点
- 主要解决的问题是全局中一个类的频繁创建和销毁
- 当我们想控制实例的数目，节省系统资源的时候使用单例模式
- 解决方法是判断当前是否有这个单例，如果有则返回，如果没有则创建
- 例子：一个班级只有一个班主任、操作文件的时候不能出现多个线程操作同一个而文件、设备管理器常常是单例模式（一台电脑插了两台打印机，每个打印机都是单例）
- 优点是在内存中只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例，节省了系统资源，并且能避免对资源的多重占用
- 缺点是没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化
- 单例模式有几种实现方法：懒汉式（线程不安全）、饿汉式（线程安全）、饿汉式、双检锁/双重校验锁（DCL，即 double-checked locking）、登记式/静态内部类、枚举
- 懒汉式（线程不安全）是一种最基本的实现，最大的问题就是不支持多线程，实现起来就是在这个类中自身类型的成员，这个自身类型的成员静态（不进行初始化），然后还要有个静态的获得方法，以通过类名调用获得方法获得对应的实体类，这个获得方法中的逻辑是先判断成员中的自身成员变量是否为null，如果为null就先实例化后返回，如果不为null就直接返回。这中方法是一种很明显的lazy loading
- 懒汉式（线程安全）也具有很良好的lazy loading，能够在多线程中很好的工作，但是效率很低，99%的情况下不需要同步，所以不建议使用这种模式，实现方法就是在获得方法上加上synchronized关键字（表示只有一个线程可以访问该方法），这样就能保证在多线程中能够正常工作，但是效率很低，建议少用
- 饿汉式没有加锁，效率很高，但是不能延迟加载，实现方法就是在类加载的时候就进行实例化（给自身的静态成员自身对象赋初值），这样就能保证在多线程中能够正常工作，但是不能延迟加载
- 双检锁/双重校验锁（DCL）是懒初始化，并且线程安全，但是实现起来有一点复杂，实现方法就是在获得方法中进行两次判断，第一次判断是为了避免不必要的同步（就是在拿锁之前先判断一下静态成员对象是否为空），第二次判断是为了在null的情况下创建实例（这时候拿锁并且再看一下是否为空，是的话实例化一个），最后返回，这样就能保证在多线程中能够正常工作，但是实现起来有一点复杂
    ```
    public class Singleton {  
        private volatile static Singleton singleton;  
        private Singleton (){}  
        public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
        }  
    }
    ```

- 登记式/静态内部类的形式是懒加载，并且线程安全，实现起来难度一般，这种方法能达到双检锁一样的功效并且实现起来相对简单，实现方法就是在自身类中创建一个静态内部类，这个静态内部类中有一个静态成员变量，这个静态成员变量就是自身类型的实例，这个静态内部类中有一个静态的获得方法，这个获得方法中的逻辑是直接返回静态内部类中的静态成员变量，这样就能保证在多线程中能够正常工作，这种方式利用了classloader机制来保证初始化的时候只有一个线程，这种方式是Singleton类被装载了，instance不一定被初始化，因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance，这样就能保证在多线程中能够正常工作
    ```
    public class Singleton {  
        private static class SingletonHolder {  
            private static final Singleton INSTANCE = new Singleton();  
        }  
        private Singleton (){}  
        public static final Singleton getInstance() {  
            return SingletonHolder.INSTANCE;  
        }  
    }
    ```

- 枚举的方法不是懒初始化，但是它线程安全，实现起来简单，这种方法没有被广泛采用，但是这是实单例模式的最佳方法
    ```
    public enum Singleton {  
        INSTANCE;  
        public void whateverMethod() {  
        }  
    }
    ```

- 不建议使用前两种懒汉方法，建议使用第三种饿汉方式，如果非得懒加载就用第五种登记式/静态内部类的方法，如果是jdk1.5以上建议使用第六种枚举的方法